I want to stop iterating on the current chat UI and instead adopt a standard chat app layout. Use the structure and behavior below as the source of truth, and align my code to it. Keep my visual theme (dark, rounded, subtle borders), but follow this architecture exactly.

High level goals:

* A scrollable message area.
* A footer that contains both the suggestion pills and the input bar.
* On mobile, the footer sits above the keyboard when typing, and drops back down when the keyboard is dismissed.
* On desktop, the footer just sits at the bottom of the page content (not fixed).
* Blur the textarea when the user scrolls while typing, which dismisses the keyboard and returns the footer to the bottom.
* Only show the scroll-to-bottom button if the user is not at the bottom.
* Suggestions hide after first send, and come back after reset.

Below is a complete working reference implementation in React + Tailwind style. Recreate this behavior in my codebase with my content and my styles.

ChatShell.tsx (reference implementation)

```tsx
import React, { useEffect, useRef, useState, useCallback } from "react";

type Message = {
  id: string;
  role: "user" | "bot";
  text: string;
};

type ChatShellProps = {
  messages: Message[];
  suggestions: string[];
  onSend: (text: string) => void;
  onResetChat: () => void;
};

export default function ChatShell({
  messages,
  suggestions,
  onSend,
  onResetChat,
}: ChatShellProps) {
  const [draft, setDraft] = useState("");
  const [hasSentMessage, setHasSentMessage] = useState(false);

  const footerRef = useRef<HTMLDivElement | null>(null);
  const scrollRegionRef = useRef<HTMLDivElement | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  const [keyboardOpen, setKeyboardOpen] = useState(false);

  const maxChars = 250;

  // keep footer above keyboard on mobile
  useEffect(() => {
    function updateForViewport() {
      if (!footerRef.current || !window.visualViewport) return;

      const vv = window.visualViewport;
      const keyboardHeight = window.innerHeight - vv.height;
      const isOpen = keyboardHeight > 0;
      setKeyboardOpen(isOpen);

      footerRef.current.style.transform = isOpen
        ? `translateY(-${keyboardHeight}px)`
        : "translateY(0)";
    }

    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", updateForViewport);
      window.visualViewport.addEventListener("scroll", updateForViewport);
    }

    updateForViewport();

    return () => {
      if (window.visualViewport) {
        window.visualViewport.removeEventListener("resize", updateForViewport);
        window.visualViewport.removeEventListener("scroll", updateForViewport);
      }
    };
  }, []);

  // blur textarea on upward scroll while keyboard is open
  useEffect(() => {
    const scrollEl = scrollRegionRef.current;
    if (!scrollEl) return;

    function handleScroll() {
      if (!keyboardOpen) return;
      // user scrolled while typing, treat that as "done typing"
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur(); // hides keyboard
      }
    }

    scrollEl.addEventListener("scroll", handleScroll, { passive: true });
    return () => {
      scrollEl.removeEventListener("scroll", handleScroll);
    };
  }, [keyboardOpen]);

  // auto grow textarea up to a cap
  const handleDraftChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      const value = e.target.value;
      if (value.length > maxChars) return;
      setDraft(value);

      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
        const next = Math.min(textareaRef.current.scrollHeight, 200);
        textareaRef.current.style.height = next + "px";
      }
    },
    []
  );

  const handleSend = useCallback(() => {
    const text = draft.trim();
    if (!text) return;
    onSend(text);
    setHasSentMessage(true);
    setDraft("");

    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }

    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }, [draft, onSend]);

  const handleSuggestClick = useCallback(
    (s: string) => {
      setDraft(s);
      setHasSentMessage(true);

      requestAnimationFrame(() => {
        textareaRef.current?.focus();
        if (textareaRef.current) {
          textareaRef.current.style.height = "auto";
          textareaRef.current.style.height =
            Math.min(textareaRef.current.scrollHeight, 200) + "px";
        }
      });
    },
    []
  );

  const handleRefresh = useCallback(() => {
    // reset chat state only, not full page reload
    onResetChat();
    setDraft("");
    setHasSentMessage(false);

    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }

    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }, [onResetChat]);

  // scroll to bottom button visibility
  const [showScrollToBottom, setShowScrollToBottom] = useState(false);
  useEffect(() => {
    const el = scrollRegionRef.current;
    if (!el) return;

    function checkBottom() {
      const distanceFromBottom =
        el.scrollHeight - (el.scrollTop + el.clientHeight);

      // show button only if there is content below the viewport
      setShowScrollToBottom(distanceFromBottom > 4);
    }

    checkBottom();
    el.addEventListener("scroll", checkBottom, { passive: true });
    return () => el.removeEventListener("scroll", checkBottom);
  }, []);

  function scrollToBottom() {
    const el = scrollRegionRef.current;
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
  }

  return (
    <div className="flex h-dvh flex-col bg-neutral-900 text-neutral-100 sm:h-auto sm:min-h-screen sm:bg-neutral-900">
      {/* Messages scroll area */}
      <div
        ref={scrollRegionRef}
        className="flex-1 overflow-y-auto px-4 py-6 space-y-4"
      >
        {messages.map(m => (
          <div
            key={m.id}
            className={`
              max-w-[80%] rounded-lg px-3 py-2 text-sm leading-relaxed
              ${
                m.role === "user"
                  ? "ml-auto bg-blue-600 text-white"
                  : "mr-auto bg-neutral-800 text-neutral-100 border border-neutral-700"
              }
            `}
          >
            {m.text}
          </div>
        ))}

        {/* sentinel for bottom */}
        <div id="chat-bottom-sentinel" className="h-1" />
      </div>

      {/* scroll to bottom button (mobile only) */}
      {showScrollToBottom && (
        <button
          onClick={scrollToBottom}
          className="absolute bottom-28 left-1/2 z-40 -translate-x-1/2 rounded-full bg-neutral-800 px-3 py-2 text-xs font-medium text-white shadow-lg ring-1 ring-neutral-700 sm:hidden"
        >
          ↓ Newer
        </button>
      )}

      {/* footer group: suggestions + input bar */}
      <div
        ref={footerRef}
        className="relative z-30 w-full bg-neutral-900/95 px-4 pb-[env(safe-area-inset-bottom)] pt-3 ring-0 sm:static sm:translate-y-0 sm:bg-transparent sm:px-4 sm:pt-6"
      >
        {/* suggestion pills:
            visible until first real send,
            visible again after reset,
            stacked/wrapped on mobile,
            no giant card wrapper */}
        {!hasSentMessage && suggestions.length > 0 && (
          <div className="mb-3 flex flex-wrap items-start justify-center gap-2 sm:justify-start">
            {suggestions.map((s, i) => (
              <button
                key={i}
                onClick={() => handleSuggestClick(s)}
                className="rounded-lg border border-neutral-600 bg-neutral-800 px-3 py-2 text-sm text-neutral-100 shadow-sm"
              >
                {s}
              </button>
            ))}
          </div>
        )}

        {/* input bar:
            refresh icon → textarea → char counter → send button
            all vertically centered in one row
            textarea grows up to ~200px then scrolls
            no plus button, no mic button */}
        <div className="flex items-end rounded-xl border border-neutral-700 bg-neutral-800 px-3 py-2 text-neutral-100 shadow-lg">
          {/* refresh / reset chat */}
          <button
            onClick={handleRefresh}
            className="mr-2 flex h-8 w-8 flex-none items-center justify-center text-neutral-300 hover:text-white"
            aria-label="Reset chat"
          >
            ⟳
          </button>

          {/* textarea and counter */}
          <div className="flex min-w-0 flex-1 flex-col">
            <textarea
              ref={textareaRef}
              className="max-h-[200px] w-full resize-none overflow-y-auto bg-transparent text-base leading-relaxed text-neutral-100 placeholder-neutral-400 outline-none"
              rows={1}
              value={draft}
              onChange={handleDraftChange}
              placeholder="Ask anything about Nick..."
            />
            <div className="flex w-full justify-end text-[11px] leading-none text-neutral-400">
              {draft.length} / {maxChars}
            </div>
          </div>

          {/* send */}
          <button
            onClick={handleSend}
            className="ml-2 flex h-9 w-9 flex-none items-center justify-center rounded-full bg-neutral-200 text-neutral-900 hover:bg-white"
            aria-label="Send"
          >
            ✈
          </button>
        </div>
      </div>
    </div>
  );
}
```

PortfolioChatPage.tsx (reference integration)

```tsx
import React, { useState } from "react";
import ChatShell from "./ChatShell";

export default function PortfolioChatPage() {
  const [messages, setMessages] = useState([
    { id: "1", role: "bot", text: "Hi, I'm Nick's AI. Ask me anything." },
  ]);

  const [sentOnce, setSentOnce] = useState(false);

  function handleSend(text: string) {
    const userMsg = {
      id: crypto.randomUUID(),
      role: "user" as const,
      text,
    };
    setMessages(prev => [...prev, userMsg]);

    // hook up streaming logic here for the bot response
    // the streaming speed should be 1 char per 10 ms globally

    setSentOnce(true);
  }

  function handleReset() {
    // reset chat state without reloading the page
    setMessages([
      { id: "1", role: "bot", text: "Hi, I'm Nick's AI. Ask me anything." },
    ]);
    setSentOnce(false);
  }

  return (
    <ChatShell
      messages={messages}
      suggestions={
        sentOnce
          ? []
          : [
              "Why should I hire Nick?",
              "What is Nick best at?",
              "What is Nick's coolest project?",
            ]
      }
      onSend={handleSend}
      onResetChat={handleReset}
    />
  );
}
```

Behavior rules you must keep when you adapt this into my site:

1. The footer is made of two stacked pieces: suggestion pills, then the input bar. Treat them as one unit called ChatFooter / ChatInputGroup. Do not let them drift apart or overlap.
2. On mobile, when the keyboard opens, the entire footer (pills + bar) lifts together so it sits just above the keyboard. Use window.visualViewport to detect keyboard height and apply translateY(-keyboardHeight). On desktop, do not make it fixed to the viewport. On desktop it can just render at the bottom of the page content like a footer.
3. When the user scrolls while the keyboard is open, call blur() on the textarea. That dismisses the keyboard and returns the footer to the resting position at the bottom.
4. Never auto scroll the page to top or jerk the layout. The only animation should be the footer translating up above the keyboard.
5. Only show the scroll-to-bottom button if there is content below the current scroll position. If the user is already at the bottom, hide it. Tapping it smooth scrolls the messages area to the bottom.
6. The suggestion pills:

   * Are visible until the first real message is sent.
   * Stay visible while the user is typing. Do not hide them on focus.
   * Hide after sending.
   * Reappear when the reset/refresh button is pressed.
   * Wrap on mobile. No giant card wrapper behind them.
7. Input bar row:

   * Icons and text are vertically centered in one line.
   * Order is refresh icon, textarea, character counter, send button (paper airplane in a circular button).
   * No plus button. No mic button.
   * The textarea grows up to a max height of about 200px, then scrolls internally.
   * Character counter should stay visible and readable.
   * Send icon must be visually centered inside its circular button.
8. Spacing:

   * Reduce bottom padding in desktop mode so the footer looks like it belongs to the bottom of the page, not floating above a huge empty gap.
   * On mobile, keep safe-area padding (env(safe-area-inset-bottom)) so it clears the OS home bar / bottom gesture area.
9. Streaming:

   * All streamed text (about me, experience, AI responses) should render at 1 character per 10 ms, with the inline blinking cursor, consistent everywhere.

Take these components and behaviors and rework my existing code so my portfolio chat section behaves like this.
